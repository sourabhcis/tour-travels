{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n};\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\nvar _react = require('react');\nvar _react2 = _interopRequireDefault(_react);\nvar _Elements = require('./Elements');\nvar _Provider = require('./Provider');\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n  return target;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\n// react-redux does a bunch of stuff with pure components / checking if it needs to re-render.\n// not sure if we need to do the same.\nvar inject = function inject(WrappedComponent) {\n  var _class, _temp;\n  var componentOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _componentOptions$wit = componentOptions.withRef,\n    withRef = _componentOptions$wit === undefined ? false : _componentOptions$wit;\n  return _temp = _class = function (_React$Component) {\n    _inherits(_class, _React$Component);\n    function _class(props, context) {\n      _classCallCheck(this, _class);\n      if (!context || !context.getRegisteredElements) {\n        throw new Error('It looks like you are trying to inject Stripe context outside of an Elements context.\\nPlease be sure the component that calls createSource or createToken is within an <Elements> component.');\n      }\n      var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));\n      _this.parseElementOrData = function (elementOrOptions) {\n        return elementOrOptions && (typeof elementOrOptions === 'undefined' ? 'undefined' : _typeof(elementOrOptions)) === 'object' && elementOrOptions._frame && _typeof(elementOrOptions._frame) === 'object' && elementOrOptions._frame.id && typeof elementOrOptions._frame.id === 'string' && typeof elementOrOptions._componentName === 'string' ? {\n          type: 'element',\n          element: elementOrOptions\n        } : {\n          type: 'data',\n          data: elementOrOptions\n        };\n      };\n      _this.findElement = function (filterBy, specifiedType) {\n        var allElements = _this.context.getRegisteredElements();\n        var filteredElements = allElements.filter(function (e) {\n          return e[filterBy];\n        });\n        var matchingElements = specifiedType === 'auto' ? filteredElements : filteredElements.filter(function (e) {\n          return e[filterBy] === specifiedType;\n        });\n        if (matchingElements.length === 1) {\n          return matchingElements[0].element;\n        } else if (matchingElements.length > 1) {\n          throw new Error('You did not specify the type of Source, Token, or PaymentMethod to create.\\n        We could not infer which Element you want to use for this operation.');\n        } else {\n          return null;\n        }\n      };\n      _this.requireElement = function (filterBy, specifiedType) {\n        var element = _this.findElement(filterBy, specifiedType);\n        if (element) {\n          return element;\n        } else {\n          throw new Error('You did not specify the type of Source, Token, or PaymentMethod to create.\\n        We could not infer which Element you want to use for this operation.');\n        }\n      };\n      _this.wrappedCreateToken = function (stripe) {\n        return function () {\n          var tokenTypeOrOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n          if (tokenTypeOrOptions && (typeof tokenTypeOrOptions === 'undefined' ? 'undefined' : _typeof(tokenTypeOrOptions)) === 'object') {\n            // First argument is options; infer the Element and tokenize\n            var opts = tokenTypeOrOptions;\n            var tokenType = opts.type,\n              rest = _objectWithoutProperties(opts, ['type']);\n            var specifiedType = typeof tokenType === 'string' ? tokenType : 'auto';\n            // Since only options were passed in, a corresponding Element must exist\n            // for the tokenization to succeed -- thus we call requireElement.\n            var element = _this.requireElement('impliedTokenType', specifiedType);\n            return stripe.createToken(element, rest);\n          } else if (typeof tokenTypeOrOptions === 'string') {\n            // First argument is token type; tokenize with token type and options\n            var _tokenType = tokenTypeOrOptions;\n            return stripe.createToken(_tokenType, options);\n          } else {\n            // If a bad value was passed in for options, throw an error.\n            throw new Error('Invalid options passed to createToken. Expected an object, got ' + (typeof tokenTypeOrOptions === 'undefined' ? 'undefined' : _typeof(tokenTypeOrOptions)) + '.');\n          }\n        };\n      };\n      _this.wrappedCreateSource = function (stripe) {\n        return function () {\n          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          if (options && (typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {\n            if (typeof options.type !== 'string') {\n              throw new Error('Invalid Source type passed to createSource. Expected string, got ' + _typeof(options.type) + '.');\n            }\n            var element = _this.findElement('impliedSourceType', options.type);\n            if (element) {\n              // If an Element exists for the source type, use that to create the\n              // corresponding source.\n              //\n              // NOTE: this prevents users from independently creating sources of\n              // type `foo` if an Element that can create `foo` sources exists in\n              // the current <Elements /> context.\n              return stripe.createSource(element, options);\n            } else {\n              // If no Element exists for the source type, directly create a source.\n              return stripe.createSource(options);\n            }\n          } else {\n            // If a bad value was passed in for options, throw an error.\n            throw new Error('Invalid options passed to createSource. Expected an object, got ' + (typeof options === 'undefined' ? 'undefined' : _typeof(options)) + '.');\n          }\n        };\n      };\n      _this.wrappedCreatePaymentMethod = function (stripe) {\n        return function (paymentMethodType, elementOrData, maybeData) {\n          if (paymentMethodType && (typeof paymentMethodType === 'undefined' ? 'undefined' : _typeof(paymentMethodType)) === 'object') {\n            return stripe.createPaymentMethod(paymentMethodType);\n          }\n          if (!paymentMethodType || typeof paymentMethodType !== 'string') {\n            throw new Error('Invalid PaymentMethod type passed to createPaymentMethod. Expected a string, got ' + (typeof paymentMethodType === 'undefined' ? 'undefined' : _typeof(paymentMethodType)) + '.');\n          }\n          var elementOrDataResult = _this.parseElementOrData(elementOrData);\n\n          // Second argument is Element; use passed in Element\n          if (elementOrDataResult.type === 'element') {\n            var _element = elementOrDataResult.element;\n            if (maybeData) {\n              return stripe.createPaymentMethod(paymentMethodType, _element, maybeData);\n            } else {\n              return stripe.createPaymentMethod(paymentMethodType, _element);\n            }\n          }\n\n          // Second argument is data or undefined; infer the Element\n          var data = elementOrDataResult.data;\n          var element = _this.findElement('impliedPaymentMethodType', paymentMethodType);\n          if (element) {\n            return data ? stripe.createPaymentMethod(paymentMethodType, element, data) : stripe.createPaymentMethod(paymentMethodType, element);\n          }\n          if (data && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {\n            return stripe.createPaymentMethod(paymentMethodType, data);\n          } else if (!data) {\n            throw new Error('Could not find an Element that can be used to create a PaymentMethod of type: ' + paymentMethodType + '.');\n          } else {\n            // If a bad value was passed in for data, throw an error.\n            throw new Error('Invalid data passed to createPaymentMethod. Expected an object, got ' + (typeof data === 'undefined' ? 'undefined' : _typeof(data)) + '.');\n          }\n        };\n      };\n      _this.wrappedHandleCardX = function (stripe, method) {\n        return function (clientSecret, elementOrData, maybeData) {\n          if (!clientSecret || typeof clientSecret !== 'string') {\n            // If a bad value was passed in for clientSecret, throw an error.\n            throw new Error('Invalid PaymentIntent client secret passed to handleCardPayment. Expected string, got ' + (typeof clientSecret === 'undefined' ? 'undefined' : _typeof(clientSecret)) + '.');\n          }\n          var elementOrDataResult = _this.parseElementOrData(elementOrData);\n\n          // Second argument is Element; handle with element\n          if (elementOrDataResult.type === 'element') {\n            var _element2 = elementOrDataResult.element;\n            if (maybeData) {\n              return stripe[method](clientSecret, _element2, maybeData);\n            } else {\n              return stripe[method](clientSecret, _element2);\n            }\n          }\n\n          // Second argument is data or undefined; see if we can find a mounted Element\n          // that can create card PaymentMethods\n          var data = elementOrDataResult.data;\n          var element = _this.findElement('impliedPaymentMethodType', 'card');\n          if (element) {\n            // If an Element exists that can create card PaymentMethods use it. Otherwise\n            // assume that we must be calling with data only.\n            //\n            // NOTE: this prevents users from using handleCard* with an existing\n            // Source or PaymentMethod if an Element that can create card PaymentMethods\n            // exists in the current <Elements /> context.\n            if (data) {\n              return stripe[method](clientSecret, element, data);\n            } else {\n              return stripe[method](clientSecret, element);\n            }\n          } else if (data) {\n            // if no element exists call handleCard* directly (with data)\n            return stripe[method](clientSecret, data);\n          } else {\n            // if no element exists call handleCard* directly (with only the clientSecret)\n            return stripe[method](clientSecret);\n          }\n        };\n      };\n      if (_this.context.tag === 'sync') {\n        _this.state = {\n          stripe: _this.stripeProps(_this.context.stripe)\n        };\n      } else {\n        _this.state = {\n          stripe: null\n        };\n      }\n      return _this;\n    }\n    _class.prototype.componentDidMount = function componentDidMount() {\n      var _this2 = this;\n      if (this.context.tag === 'async') {\n        this.context.addStripeLoadListener(function (stripe) {\n          _this2.setState({\n            stripe: _this2.stripeProps(stripe)\n          });\n        });\n      } else {\n        // when 'sync', it's already set in the constructor.\n      }\n    };\n    _class.prototype.getWrappedInstance = function getWrappedInstance() {\n      if (!withRef) {\n        throw new Error('To access the wrapped instance, the `{withRef: true}` option must be set when calling `injectStripe()`');\n      }\n      return this.wrappedInstance;\n    };\n    _class.prototype.stripeProps = function stripeProps(stripe) {\n      return _extends({}, stripe, {\n        // These are the only functions that take elements.\n        createToken: this.wrappedCreateToken(stripe),\n        createSource: this.wrappedCreateSource(stripe),\n        createPaymentMethod: this.wrappedCreatePaymentMethod(stripe),\n        handleCardPayment: this.wrappedHandleCardX(stripe, 'handleCardPayment'),\n        handleCardSetup: this.wrappedHandleCardX(stripe, 'handleCardSetup')\n      });\n    };\n\n    // Finds an Element by the specified type, if one exists.\n    // Throws if multiple Elements match.\n\n    // Require that exactly one Element is found for the specified type.\n    // Throws if no Element is found.\n\n    // Wraps createToken in order to infer the Element that is being tokenized.\n\n    // Wraps createSource in order to infer the Element that is being used for\n    // source creation.\n\n    // Wraps createPaymentMethod in order to infer the Element that is being\n    // used for PaymentMethod creation.\n\n    _class.prototype.render = function render() {\n      var _this3 = this;\n      return _react2.default.createElement(WrappedComponent, _extends({}, this.props, {\n        stripe: this.state.stripe,\n        elements: this.context.elements,\n        ref: withRef ? function (c) {\n          _this3.wrappedInstance = c;\n        } : null\n      }));\n    };\n    return _class;\n  }(_react2.default.Component), _class.contextTypes = _extends({}, _Provider.providerContextTypes, _Elements.injectContextTypes), _class.displayName = 'InjectStripe(' + (WrappedComponent.displayName || WrappedComponent.name || 'Component') + ')', _temp;\n};\nexports.default = inject;","map":{"version":3,"names":["Object","defineProperty","exports","value","_extends","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","_typeof","Symbol","iterator","obj","constructor","_react","require","_react2","_interopRequireDefault","_Elements","_Provider","__esModule","default","_objectWithoutProperties","keys","indexOf","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","enumerable","writable","configurable","setPrototypeOf","__proto__","inject","WrappedComponent","_class","_temp","componentOptions","undefined","_componentOptions$wit","withRef","_React$Component","props","context","getRegisteredElements","Error","_this","parseElementOrData","elementOrOptions","_frame","id","_componentName","type","element","data","findElement","filterBy","specifiedType","allElements","filteredElements","filter","e","matchingElements","requireElement","wrappedCreateToken","stripe","tokenTypeOrOptions","options","opts","tokenType","rest","createToken","_tokenType","wrappedCreateSource","createSource","wrappedCreatePaymentMethod","paymentMethodType","elementOrData","maybeData","createPaymentMethod","elementOrDataResult","_element","wrappedHandleCardX","method","clientSecret","_element2","tag","state","stripeProps","componentDidMount","_this2","addStripeLoadListener","setState","getWrappedInstance","wrappedInstance","handleCardPayment","handleCardSetup","render","_this3","createElement","elements","ref","c","Component","contextTypes","providerContextTypes","injectContextTypes","displayName","name"],"sources":["/windows/sourabh 3.0/MernStack-Tour-Management/tour-management/frontend/node_modules/react-stripe-elements/es/components/inject.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _Elements = require('./Elements');\n\nvar _Provider = require('./Provider');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// react-redux does a bunch of stuff with pure components / checking if it needs to re-render.\n// not sure if we need to do the same.\nvar inject = function inject(WrappedComponent) {\n  var _class, _temp;\n\n  var componentOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _componentOptions$wit = componentOptions.withRef,\n      withRef = _componentOptions$wit === undefined ? false : _componentOptions$wit;\n\n\n  return _temp = _class = function (_React$Component) {\n    _inherits(_class, _React$Component);\n\n    function _class(props, context) {\n      _classCallCheck(this, _class);\n\n      if (!context || !context.getRegisteredElements) {\n        throw new Error('It looks like you are trying to inject Stripe context outside of an Elements context.\\nPlease be sure the component that calls createSource or createToken is within an <Elements> component.');\n      }\n\n      var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));\n\n      _this.parseElementOrData = function (elementOrOptions) {\n        return elementOrOptions && (typeof elementOrOptions === 'undefined' ? 'undefined' : _typeof(elementOrOptions)) === 'object' && elementOrOptions._frame && _typeof(elementOrOptions._frame) === 'object' && elementOrOptions._frame.id && typeof elementOrOptions._frame.id === 'string' && typeof elementOrOptions._componentName === 'string' ? { type: 'element', element: elementOrOptions } : { type: 'data', data: elementOrOptions };\n      };\n\n      _this.findElement = function (filterBy, specifiedType) {\n        var allElements = _this.context.getRegisteredElements();\n        var filteredElements = allElements.filter(function (e) {\n          return e[filterBy];\n        });\n        var matchingElements = specifiedType === 'auto' ? filteredElements : filteredElements.filter(function (e) {\n          return e[filterBy] === specifiedType;\n        });\n\n        if (matchingElements.length === 1) {\n          return matchingElements[0].element;\n        } else if (matchingElements.length > 1) {\n          throw new Error('You did not specify the type of Source, Token, or PaymentMethod to create.\\n        We could not infer which Element you want to use for this operation.');\n        } else {\n          return null;\n        }\n      };\n\n      _this.requireElement = function (filterBy, specifiedType) {\n        var element = _this.findElement(filterBy, specifiedType);\n        if (element) {\n          return element;\n        } else {\n          throw new Error('You did not specify the type of Source, Token, or PaymentMethod to create.\\n        We could not infer which Element you want to use for this operation.');\n        }\n      };\n\n      _this.wrappedCreateToken = function (stripe) {\n        return function () {\n          var tokenTypeOrOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n          if (tokenTypeOrOptions && (typeof tokenTypeOrOptions === 'undefined' ? 'undefined' : _typeof(tokenTypeOrOptions)) === 'object') {\n            // First argument is options; infer the Element and tokenize\n            var opts = tokenTypeOrOptions;\n\n            var tokenType = opts.type,\n                rest = _objectWithoutProperties(opts, ['type']);\n\n            var specifiedType = typeof tokenType === 'string' ? tokenType : 'auto';\n            // Since only options were passed in, a corresponding Element must exist\n            // for the tokenization to succeed -- thus we call requireElement.\n            var element = _this.requireElement('impliedTokenType', specifiedType);\n            return stripe.createToken(element, rest);\n          } else if (typeof tokenTypeOrOptions === 'string') {\n            // First argument is token type; tokenize with token type and options\n            var _tokenType = tokenTypeOrOptions;\n            return stripe.createToken(_tokenType, options);\n          } else {\n            // If a bad value was passed in for options, throw an error.\n            throw new Error('Invalid options passed to createToken. Expected an object, got ' + (typeof tokenTypeOrOptions === 'undefined' ? 'undefined' : _typeof(tokenTypeOrOptions)) + '.');\n          }\n        };\n      };\n\n      _this.wrappedCreateSource = function (stripe) {\n        return function () {\n          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n          if (options && (typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {\n            if (typeof options.type !== 'string') {\n              throw new Error('Invalid Source type passed to createSource. Expected string, got ' + _typeof(options.type) + '.');\n            }\n\n            var element = _this.findElement('impliedSourceType', options.type);\n            if (element) {\n              // If an Element exists for the source type, use that to create the\n              // corresponding source.\n              //\n              // NOTE: this prevents users from independently creating sources of\n              // type `foo` if an Element that can create `foo` sources exists in\n              // the current <Elements /> context.\n              return stripe.createSource(element, options);\n            } else {\n              // If no Element exists for the source type, directly create a source.\n              return stripe.createSource(options);\n            }\n          } else {\n            // If a bad value was passed in for options, throw an error.\n            throw new Error('Invalid options passed to createSource. Expected an object, got ' + (typeof options === 'undefined' ? 'undefined' : _typeof(options)) + '.');\n          }\n        };\n      };\n\n      _this.wrappedCreatePaymentMethod = function (stripe) {\n        return function (paymentMethodType, elementOrData, maybeData) {\n          if (paymentMethodType && (typeof paymentMethodType === 'undefined' ? 'undefined' : _typeof(paymentMethodType)) === 'object') {\n            return stripe.createPaymentMethod(paymentMethodType);\n          }\n\n          if (!paymentMethodType || typeof paymentMethodType !== 'string') {\n            throw new Error('Invalid PaymentMethod type passed to createPaymentMethod. Expected a string, got ' + (typeof paymentMethodType === 'undefined' ? 'undefined' : _typeof(paymentMethodType)) + '.');\n          }\n\n          var elementOrDataResult = _this.parseElementOrData(elementOrData);\n\n          // Second argument is Element; use passed in Element\n          if (elementOrDataResult.type === 'element') {\n            var _element = elementOrDataResult.element;\n\n            if (maybeData) {\n              return stripe.createPaymentMethod(paymentMethodType, _element, maybeData);\n            } else {\n              return stripe.createPaymentMethod(paymentMethodType, _element);\n            }\n          }\n\n          // Second argument is data or undefined; infer the Element\n          var data = elementOrDataResult.data;\n\n          var element = _this.findElement('impliedPaymentMethodType', paymentMethodType);\n\n          if (element) {\n            return data ? stripe.createPaymentMethod(paymentMethodType, element, data) : stripe.createPaymentMethod(paymentMethodType, element);\n          }\n\n          if (data && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {\n            return stripe.createPaymentMethod(paymentMethodType, data);\n          } else if (!data) {\n            throw new Error('Could not find an Element that can be used to create a PaymentMethod of type: ' + paymentMethodType + '.');\n          } else {\n            // If a bad value was passed in for data, throw an error.\n            throw new Error('Invalid data passed to createPaymentMethod. Expected an object, got ' + (typeof data === 'undefined' ? 'undefined' : _typeof(data)) + '.');\n          }\n        };\n      };\n\n      _this.wrappedHandleCardX = function (stripe, method) {\n        return function (clientSecret, elementOrData, maybeData) {\n          if (!clientSecret || typeof clientSecret !== 'string') {\n            // If a bad value was passed in for clientSecret, throw an error.\n            throw new Error('Invalid PaymentIntent client secret passed to handleCardPayment. Expected string, got ' + (typeof clientSecret === 'undefined' ? 'undefined' : _typeof(clientSecret)) + '.');\n          }\n\n          var elementOrDataResult = _this.parseElementOrData(elementOrData);\n\n          // Second argument is Element; handle with element\n          if (elementOrDataResult.type === 'element') {\n            var _element2 = elementOrDataResult.element;\n\n            if (maybeData) {\n              return stripe[method](clientSecret, _element2, maybeData);\n            } else {\n              return stripe[method](clientSecret, _element2);\n            }\n          }\n\n          // Second argument is data or undefined; see if we can find a mounted Element\n          // that can create card PaymentMethods\n          var data = elementOrDataResult.data;\n\n          var element = _this.findElement('impliedPaymentMethodType', 'card');\n\n          if (element) {\n            // If an Element exists that can create card PaymentMethods use it. Otherwise\n            // assume that we must be calling with data only.\n            //\n            // NOTE: this prevents users from using handleCard* with an existing\n            // Source or PaymentMethod if an Element that can create card PaymentMethods\n            // exists in the current <Elements /> context.\n            if (data) {\n              return stripe[method](clientSecret, element, data);\n            } else {\n              return stripe[method](clientSecret, element);\n            }\n          } else if (data) {\n            // if no element exists call handleCard* directly (with data)\n            return stripe[method](clientSecret, data);\n          } else {\n            // if no element exists call handleCard* directly (with only the clientSecret)\n            return stripe[method](clientSecret);\n          }\n        };\n      };\n\n      if (_this.context.tag === 'sync') {\n        _this.state = {\n          stripe: _this.stripeProps(_this.context.stripe)\n        };\n      } else {\n        _this.state = {\n          stripe: null\n        };\n      }\n      return _this;\n    }\n\n    _class.prototype.componentDidMount = function componentDidMount() {\n      var _this2 = this;\n\n      if (this.context.tag === 'async') {\n        this.context.addStripeLoadListener(function (stripe) {\n          _this2.setState({\n            stripe: _this2.stripeProps(stripe)\n          });\n        });\n      } else {\n        // when 'sync', it's already set in the constructor.\n      }\n    };\n\n    _class.prototype.getWrappedInstance = function getWrappedInstance() {\n      if (!withRef) {\n        throw new Error('To access the wrapped instance, the `{withRef: true}` option must be set when calling `injectStripe()`');\n      }\n      return this.wrappedInstance;\n    };\n\n    _class.prototype.stripeProps = function stripeProps(stripe) {\n      return _extends({}, stripe, {\n        // These are the only functions that take elements.\n        createToken: this.wrappedCreateToken(stripe),\n        createSource: this.wrappedCreateSource(stripe),\n        createPaymentMethod: this.wrappedCreatePaymentMethod(stripe),\n        handleCardPayment: this.wrappedHandleCardX(stripe, 'handleCardPayment'),\n        handleCardSetup: this.wrappedHandleCardX(stripe, 'handleCardSetup')\n      });\n    };\n\n    // Finds an Element by the specified type, if one exists.\n    // Throws if multiple Elements match.\n\n\n    // Require that exactly one Element is found for the specified type.\n    // Throws if no Element is found.\n\n\n    // Wraps createToken in order to infer the Element that is being tokenized.\n\n\n    // Wraps createSource in order to infer the Element that is being used for\n    // source creation.\n\n\n    // Wraps createPaymentMethod in order to infer the Element that is being\n    // used for PaymentMethod creation.\n\n\n    _class.prototype.render = function render() {\n      var _this3 = this;\n\n      return _react2.default.createElement(WrappedComponent, _extends({}, this.props, {\n        stripe: this.state.stripe,\n        elements: this.context.elements,\n        ref: withRef ? function (c) {\n          _this3.wrappedInstance = c;\n        } : null\n      }));\n    };\n\n    return _class;\n  }(_react2.default.Component), _class.contextTypes = _extends({}, _Provider.providerContextTypes, _Elements.injectContextTypes), _class.displayName = 'InjectStripe(' + (WrappedComponent.displayName || WrappedComponent.name || 'Component') + ')', _temp;\n};\n\nexports.default = inject;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}